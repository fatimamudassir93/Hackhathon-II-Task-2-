["spec.md](./spec.md)\n**Plan**: [plan.md](./plan.md)\n**Data Model**: [data-model.md](./data-model.md)\n**Contracts**: [contracts/](./contracts/)\n\n## Prerequisites\n\n- Python 3.11 or later\n- pytest (for testing)\n- Basic understanding of Python dataclasses and enums\n\n## Project Setup\n\n```bash\n# Create project directory structure\ncd /path/to/todo-app\nmkdir -p src/{models,services,commands,ui} tests/{unit,integration}\n\n# Create placeholder files\ntouch src/__init__.py\ntouch src/models/__init__.py\ntouch src/services/__init__.py\ntouch src/commands/__init__.py\ntouch src/ui/__init__.py\ntouch src/app.py\ntouch src/cli.py\n```\n\n## Step 1: Implement Task Entity (src/models/task.py)\n\n```python\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass TaskStatus(Enum):\n    \"", "Task completion status (invariant #2: single phase-state).\"", "\n    PENDING = \"pending\"\n    COMPLETED = \"completed\"\n\n@dataclass\nclass Task:\n    \"", "Task entity representing a single to-do item.\n\n    Attributes:\n        id: Unique sequential identifier (invariant #1)\n        description: Non-empty text description\n        status: Either PENDING or COMPLETED (invariant #2)\n\n    Note: Invariant #3 (append-only history) deferred to Phase II.\n          Invariant #4 (completed immutability) enforced in store layer.\n    \"", "\n    id: int\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n```\n\n## Step 2: Implement TaskStore (src/services/store.py)\n\n```python\nfrom typing import Dict, List\nfrom models.task import Task, TaskStatus\n\nclass TaskStore:\n    \"", "In-memory task repository with CRUD operations.\n\n    FR-012: In-memory only (no files, no DB).\n    FR-014: Sequential IDs starting at 1.\n    FR-013: Clear all data on exit (session-scoped).\n    \"", "\n\n    def __init__(self) -> None:\n        self._tasks: Dict[int, Task] = {}\n        self._next_id: int = 1\n\n    def add(self, description: str) -> Task:\n        \"", "Add new task with next sequential ID and PENDING status.\"", "\n        if not description or description.isspace():\n            raise ValueError(\"Task description cannot be empty", "task = Task(\n            id=self._next_id,\n            description=description.strip(),\n            status=TaskStatus.PENDING\n        )\n        self._tasks[task.id] = task\n        self._next_id += 1\n        return task\n\n    def get(self, task_id: int) -> Task:\n        \"", "Retrieve task by ID.\"", "\n        if task_id not in self._tasks:\n            raise KeyError(f\"Task {task_id} not found", "return self._tasks[task_id]\n\n    def delete(self, task_id: int) -> None:\n        \"", "Remove task from store.\"", "\n        if task_id not in self._tasks:\n            raise KeyError(f\"Task {task_id} not found", "del self._tasks[task_id]\n\n    def update_description(self, task_id: int, new_description: str) -> Task:\n        \"", "Update task description (invariant #4: completed tasks immutable).\"", "\n        task = self.get(task_id)\n        if task.status == TaskStatus.COMPLETED:\n            raise ValueError(\"Cannot update completed tasks (immutable per invariant #4)\")\n        if not new_description or new_description.isspace():\n            raise ValueError(\"Task description cannot be empty", "task.description = new_description.strip()\n        return task\n\n    def complete(self, task_id: int) -> Task:\n        \"", "Mark task as COMPLETED.\"", "\n        task = self.get(task_id)\n        if task.status == TaskStatus.COMPLETED:\n            raise ValueError(f\"Task {task_id} is already completed", "task.status = TaskStatus.COMPLETED\n        return task\n\n    def get_all(self) -> List[Task]:\n        \"", "Return all tasks in insertion order (FR-015).\"", "\n        return [self._tasks[task_id] for task_id in sorted(self._tasks.keys())]\n\n    def get_by_status(self, status: TaskStatus) -> List[Task]:\n        \"", "Return tasks filtered by status (for US5 - view by status).\"", "\n        return [task for task in self.get_all() if task.status == status]\n\n    def clear(self) -> None:\n        \"", "Remove all tasks (FR-013 - clear on exit).\"", "\n        self._tasks.clear()\n        self._next_id = 1\n```\n\n## Step 3: Implement UI Renderer (src/ui/renderer.py)\n\n```python\nimport sys\nfrom typing import List\nfrom models.task import Task, TaskStatus\n\nclass ConsoleRenderer:\n    \"", "Console rendering with ANSI color and framing.\n\n    FR-011: ANSI color codes with graceful fallback.\n    FR-002: Framed task list display.\n    \"", "\n\n    # ANSI color codes\n    RESET = \"033[0m\"\n    DIM_GRAY = \"033[90m\"\n    BRIGHT_WHITE = \"033[97m\"\n    YELLOW = \"033[93m\"\n    GREEN = \"033[92m\"\n    CYAN = \"033[96m\"\n    RED = \"033[91m", "def __init__(self, use_color: bool = None):\n        \"", "Initialize renderer.\n\n        Args:\n            use_color: Force color on/off. Auto-detects if None.\n        \"", "\n        if use_color is None:\n            self.use_color = sys.stdout.isatty()\n        else:\n            self.use_color = use_color\n\n    def _color(self, text: str, color_code: str) -> str:\n        \"", "Apply color if enabled, otherwise return plain text.\"", "\n        if self.use_color:\n            return f\"{color_code}{text}{self.RESET}", "return text\n\n    def _format_task_line(self, task: Task) -> str:\n        \"", "Format task line with status marker, ID, and description.\"", "\n        status_marker = (\n            self._color(", [", self.GREEN)\n            if task.status == TaskStatus.COMPLETED\n            else self._color(", [", self.YELLOW)\n        )\n        id_str = self._color(f\"{task.id:3}", "self.CYAN)\n        return f\"{status_marker}{id_str}: {task.description}", "def render_frame(self, tasks: List[Task], title: str = \"TODO LIST\") -> str:\n        \"", "Render framed task list.\n\n        FR-002: Display all tasks in framed, organized console output.\n        FR-017: Handle text overflow (word-wrap within frame).\n        \"", "\n        width = 78  # 80 columns minus 2 frame borders\n        border = self._color(\"\u2500", "width, self.DIM_GRAY)\n\n        lines = [\n            self._color(f\"\u250c{border}\u2510", "self.DIM_GRAY),\n            self._color(f\"\u2502{title.center(width)}\u2502", "self.BRIGHT_WHITE),\n            self._color(f\"\u251c{border}\u2524", "self.DIM_GRAY),\n        ]\n\n        if not tasks:\n            lines.append(self._color(f\"\u2502{'No tasks'.center(width)}\u2502", "self.DIM_GRAY))\n        else:\n            for task in tasks:\n                task_line = self._format_task_line(task)\n                # Simple truncation for now (word-wrap handled in formatter module)\n                task_line = (task_line + \"", 78, [78], "lines.append(self._color(f\"\u2502{task_line}\u2502", "self.DIM_GRAY))\n\n        lines.append(self._color(f\"\u2514{border}\u2518", "self.DIM_GRAY))\n\n        # Footer with summary\n        pending = sum(1 for t in tasks if t.status == TaskStatus.PENDING)\n        completed = sum(1 for t in tasks if t.status == TaskStatus.COMPLETED)\n        summary = f", {"completed)": "ines.append(self._color(summary.center(80)", "\\n": "join(lines)\n```\n\n## Step 4: Implement Command Handlers\n\n### src/commands/add.py\n\n```python\nfrom services.store import TaskStore\nfrom ui.renderer import ConsoleRenderer\n\ndef handle_add(store: TaskStore", "description": "str) -> str:", "Handle add command.\"": "try:\n        task = store.add(description)\n        renderer = ConsoleRenderer()\n        output = f", "added": "{task.description}\"\n\"\n        output += renderer.render_frame(store.get_all())\n        return output\n    except ValueError as e:\n        renderer = ConsoleRenderer()\n        return renderer._color(f", "Error": {"e}": "renderer.RED)\n```\n\n### src/commands/complete.py\n\n```python\nfrom services.store import TaskStore\nfrom ui.renderer import ConsoleRenderer\n\ndef handle_complete(store: TaskStore", "task_id": "int) -> str:", "Handle complete command.\"": "try:\n        task = store.complete(task_id)\n        renderer = ConsoleRenderer()\n        output = f", "completed": "{task.description}\"", "e": "renderer = ConsoleRenderer()\n        return renderer._color(f", "Error": {"e}": "renderer.RED)\n```\n\n### src/commands/view.py\n\n```python\nfrom services.store import TaskStore\nfrom models.task import TaskStatus\nfrom ui.renderer import ConsoleRenderer\n\ndef handle_view(store: TaskStore", "status_filter": "TaskStatus = None) -> str:", "Handle view command with optional status filter.\"": "renderer = ConsoleRenderer()\n    if status_filter:\n        tasks = store.get_by_status(status_filter)\n    else:\n        tasks = store.get_all()\n    return renderer.render_frame(tasks)\n```\n\n## Step 5: Implement Entry Point (src/app.py)\n\n```python\nimport argparse\nfrom services.store import TaskStore\nfrom ui.renderer import ConsoleRenderer\nfrom commands import add", "None": "", "application.\"": "parser = argparse.ArgumentParser(description=", "parser.add_subparsers(dest=\"command": "help=", "subparsers.add_parser(\"add": "help=", "add_parser.add_argument(\"description": "help=", "subparsers.add_parser(\"complete": "help=", "complete_parser.add_argument(\"id": "type=int", "subparsers.add_parser(\"view": "help=", "view_parser.add_argument(\"--pending": "action=", "store_true": "help=", "view_parser.add_argument(\"--completed": "action=", "completed": "args = parser.parse_args()\n\n    if not args.command:\n        parser.print_help()\n        return\n\n    store = TaskStore()\n\n    if args.command ==", "add": "output = add.handle_add(store", "complete": "output = complete.handle_complete(store", "view": "from models.task import TaskStatus\n        status = None\n        if args.pending:\n            status = TaskStatus.PENDING\n        elif args.completed:\n            status = TaskStatus.COMPLETED\n        output = view.handle_view(store", "else": "output = f", "Error": "Unknown command '{args.command"}, "\n\n    print(output)\n\nif __name__ == \"__main__": "main()\n```\n\n## Step 6: Run and Test\n\n```bash\n# Install pytest (if not already installed)\npip install pytest\n\n# Run the application\npython src/app.py add", "Finish report": "ython src/app.py complete 1\npython src/app.py view --pending\npython src/app.py view\n\n# Run tests (create test files first)\npytest tests/ -v\n```\n\n## Example Output\n\n```\nTask 1 added:", "groceries": "TODO LIST                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [ ]   1: Buy groceries                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n1 tasks total (1 pending"}}]]]